import {stat, readFile} from 'fs/promises';
import fg from 'fast-glob';

/**
 * Альтернативный способ загрузки данных с использованием цепочки .then()
 * 1. Сначала находит все файлы в директории for_bin_trees
 * 2. Получает метаданные (stat) для каждого файла
 * 3. Затем читает содержимое файлов в кодировке UTF-8
 * 4. Выводит содержимое и метаданные
 * 
 * Минусы подхода:
 * - Сложная вложенность колбэков ("callback hell")
 * - Менее читаемый код
 * - Плохая обработка ошибок
 */
// await fg('for_bin_trees/*')
//     .then(files =>
//         Promise.all(files.map((file) => stat(file)))
//             .then(stats =>
//                 Promise.all(files.map((file) => readFile(file, 'utf8')))
//                     .then(contents => {
//                         console.log(contents)
//                         console.log(stats)
//                     })
//             )
//     );

/**
 * Улучшенный способ загрузки данных с использованием .then() и деструктуризации
 * 1. Находит все файлы в директории for_bin_trees
 * 2. Параллельно получает метаданные и читает содержимое файлов
 * 3. Использует Promise.all для одновременного выполнения всех операций
 * 4. Получает результаты в виде массива [stats, contents] через деструктуризацию
 * 
 * Преимущества:
 * - Более плоская структура кода
 * - Параллельное выполнение операций чтения и получения метаданных
 * - Лучшая производительность по сравнению с вложенным подходом
 */
// await fg('for_bin_trees/*')
//     .then(files =>
//         Promise.all([
//             Promise.all(files.map(file => stat(file))),
//             Promise.all(files.map(file => readFile(file, 'utf8')))
//         ])
//     )
//     .then(([stats, contents]) => {
//         console.log(stats);
//         console.log(contents);
//     });


const files = await fg('for_bin_trees/*');

/**
 * Получает метаданные для каждого найденного файла
 * 
 * Использует Promise.all() для параллельного выполнения всех операций stat()
 * Это значительно быстрее, чем последовательный вызов.
 * 
 * Возвращаемые данные включают:
 * - Размер файла (size)
 * - Даты создания и изменения (birthtime, mtime)
 * - Атрибуты файла
 * 
 * @type {Promise<fs.Stats[]>}
 */
const stats = await Promise.all(files.map(file => stat(file)));

/**
 * Читает содержимое всех файлов в указанной кодировке (UTF-8)
 * 
 * Использует Promise.all() для параллельного чтения всех файлов,
 * что обеспечивает максимальную производительность.
 * 
 * Результат - массив строк, где каждый элемент соответствует содержимому одного файла.
 * 
 * @type {Promise<string[]>}
 */
const contents = await Promise.all(files.map(file => readFile(file, 'utf8')));

/**
 * Преобразует содержимое файлов в бинарное представление на уровне байтов
 * 
 * Процесс:
 * 1. Читает файлы как бинарные данные (Buffer)
 * 2. Преобразует каждый буфер в массив байтов
 * 3. Каждый байт конвертируется в 8-битную двоичную строку с дополнением нулями
 * 
 * Пример: байт 65 (символ 'A') -> '01000001'
 * 
 * Это фундаментально для алгоритмов, работающих на битовом уровне,
 * таких как:
 * - Алгоритмы сжатия (Хаффмана, LZW)
 * - Криптографические алгоритмы
 * - Построение оптимальных бинарных деревьев
 * 
 * @type {string[][]} Массив, где каждый элемент - массив двоичных строк для соответствующего файла
 */
const contents_binary = await Promise.all(files.map(file => readFile(file)))
    .then(buffers =>
        buffers.map(buffer =>
            Array.from(buffer)
                .flatMap(byte =>
                    byte
                        .toString(2)
                        .padStart(8, '0')
                )
        )
    );

/**
 * Собирает все уникальные символы из содержимого всех файлов
 * 
 * Использует Set для автоматического исключения дубликатов.
 * Это критически важно для алгоритмов, основанных на частотном анализе,
 * таких как построение дерева Хаффмана.
 * 
 * Процесс:
 * 1. Объединяет содержимое всех файлов
 * 2. Разбивает каждую строку на отдельные символы
 * 3. Фильтрует уникальные символы
 * 
 * Результат используется для:
 * - Подсчёта частоты появления каждого символа
 * - Построения оптимального префиксного кода
 * - Создания эффективного алгоритма сжатия
 * 
 * @type {Set<string>} Набор уникальных символов
 */
const uniqueChars = new Set(
    contents.flatMap(content => Array.from(content))
);

/**
 * Создает таблицу преобразования символов в их бинарное представление
 * 
 * Для каждого уникального символа генерирует объект с двумя полями:
 * - char: сам символ
 * - binary: его ASCII-код в 8-битном двоичном формате
 * 
 * Это демонстрирует основы кодирования символов и является отправной точкой
 * для понимания более сложных схем кодирования (как переменной длины у Хаффмана).
 * 
 * Пример результата:
 * [
 *   { char: 'A', binary: '01000001' },
 *   { char: 'B', binary: '01000010' }
 * ]
 * 
 * @type {{char: string, binary: string}[]}
 */
const tableData = Array.from(uniqueChars).flatMap(content =>
    Array.from(content).map(char => {
        const code = char.charCodeAt(0);
        return {
            char,
            binary: code.toString(2).padStart(8, '0')
        };
    })
);

// Выводим бинарное представление содержимого файлов (по байтам)
console.log(contents_binary)

// Выводим таблицу символов и их двоичных кодов в удобном формате
console.table(tableData);