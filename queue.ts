/**
 * Двусторонняя очередь (deque) — структура данных, позволяющая добавлять и удалять элементы
 * с обоих концов: спереди (front) и сзади (back).
 *
 * Основные операции:
 * - pushFront(value)   → добавить в начало
 * - pushBack(value)    → добавить в конец
 * - popFront()         → удалить и вернуть первый элемент
 * - popBack()          → удалить и вернуть последний элемент
 * - peekFront()        → посмотреть первый, не удаляя
 * - peekBack()         → посмотреть последний, не удаляя
 * - isEmpty()          → проверить, пуста ли очередь
 * - size()             → получить текущее количество элементов
 *
 * Реализация на основе массива (для простоты), но можно использовать связный список для лучшей производительности.
 *
 * Где применяется deque:
 * - Обход в ширину (BFS): обеспечивает порядок посещения узлов по уровням
 * - Скользящее окно: эффективное поддержание подмассива фиксированного размера
 * - Задачи с приоритетом на оба конца: например, планирование задач с разными приоритетами
 * - Алгоритмы на строках: проверка палиндромов, обработка выражений
 * - Кэши LRU (Least Recently Used): быстрое перемещение элементов в начало
 *
 * В BFS deque гарантирует, что все узлы одного уровня будут обработаны перед переходом
 * к следующему, что позволяет находить кратчайший путь. В задачах со скользящим окном
 * он позволяет за O(1) добавлять и удалять элементы с обоих концов, поддерживая оптимальное состояние.
 */
class Deque<T> {
    private items: T[] = [];

    // Добавить элемент в начало
    pushFront(item: T): void {
        this.items.unshift(item);
    }

    // Добавить элемент в конец
    pushBack(item: T): void {
        this.items.push(item);
    }

    // Удалить и вернуть первый элемент
    popFront(): T | undefined {
        return this.items.shift();
    }

    // Удалить и вернуть последний элемент
    popBack(): T | undefined {
        return this.items.pop();
    }

    // Посмотреть первый элемент без удаления
    peekFront(): T | undefined {
        return this.items[0];
    }

    // Посмотреть последний элемент без удаления
    peekBack(): T | undefined {
        return this.items[this.items.length - 1];
    }

    // Проверить, пуста ли очередь
    isEmpty(): boolean {
        return this.items.length === 0;
    }

    // Текущая длина
    size(): number {
        return this.items.length;
    }
}

// Пример использования
const deque = new Deque<number>();

// Добавляем элемент 1 в конец очереди → [1]
deque.pushBack(1);

// Добавляем элемент 2 в конец очереди → [1, 2]
deque.pushBack(2);

// Добавляем элемент 0 в начало очереди → [0, 1, 2]
deque.pushFront(0);

// Просмотр первого элемента без удаления
console.log(deque.peekFront()); // 0 (ничего не изменилось)

// Удаление и получение последнего элемента
console.log(deque.popBack());   // 2 → теперь [0, 1]

// Удаление и получение первого элемента
console.log(deque.popFront());  // 0 → теперь [1]

// Получение текущего количества элементов
console.log(deque.size());      // 1 (остался один элемент)